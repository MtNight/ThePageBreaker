<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <script type="text/javascript">
    window.addEventListener('load', init, false);
    function init()
    {
        //document.addEventListener('keypress', onKeyPressFunc(event), false);
        document.onkeydown = onKeyDownFunc;
        document.onkeypress = onKeyPressFunc;
        document.onkeyup = onKeyUpFunc;
        document.onmousemove = onMouseMoveFunc;
        var Canvas = document.getElementById('canvas');
        var Context = Canvas.getContext('2d');
        document.getElementById('container').style.left = window.innerWidth / 2 - 400 + 'px';

        var frame = 60;
        var deltaTime = 1 / frame;

        var System = { Game: 0, Pause: 0, Life: 2, Bomb: 1, TapSize: 10, CurrentTap: 0 };

        var Taps = new Array();
        createWindow(Taps);

        var tapCorrection = 1 / 15;
        var Link = new Array();
        for (var i = 0; i < 4; i++)
        {
            var links = { type: "link", x: Canvas.width / 2, y: Canvas.height / 2, size: 8, active: false };
            switch (i)
            {
                case 0: links.y += Canvas.height * tapCorrection * 6.5; break;
                case 1: links.x += Canvas.width * tapCorrection * 6.5; break;
                case 2: links.y -= Canvas.height * tapCorrection * 6.5; break;
                case 3: links.x -= Canvas.width * tapCorrection * 6.5; break;
            }
            Link.push(links);
        }

        var Objects = new Array();
        for (var i = 0; i < 4; i++)
        {
            var walls = { type: "wall", x: Canvas.width / 2, y: Canvas.height / 2, w: Canvas.width, h: Canvas.height };
            switch (i) {
                case 0: walls.y += Canvas.height * tapCorrection * 7; walls.h *= tapCorrection; break;
                case 1: walls.x += Canvas.width * tapCorrection * 7; walls.w *= tapCorrection; break;
                case 2: walls.y -= Canvas.height * tapCorrection * 7; walls.h *= tapCorrection; break;
                case 3: walls.x -= Canvas.width * tapCorrection * 7; walls.w *= tapCorrection; break;
            }
            Objects.push(walls);
        }

        var Player = { type: "player", x: 400, y: 300, angle: 0, speed: 40, size: 8, dx: 0, dy: 0, attackCool: 0 };
        var Cursor = { type: "player", x: 0, y: 0, angle: 0, size: 10 };
        var Enemies = new Array();
        var Pbullet = new Array();
        var Ebullet = new Array();

        var eBulletNum = 10;
        var tempBall;
        for (var i = 0; i < eBulletNum; i++)
        {
            var tempAngle = Math.floor(Math.random() * 360);
            tempBall = { type: "eBullet", bulletType: "repl", x: 100, y: 100, angle: tempAngle, speed: 20, size: 5, dx: 0, dy: 0, bs: 0}
            Ebullet.push(tempBall);
        }
        Ebullet[0].bulletType = "sin";

        setInterval(update, deltaTime);
        function update()
        {
            draw();
            collision();
            //stat

            //Pattack
            if (Player.attackCool == 0 && attcking == 1) {
                Player.attackCool = 1;
                //createBullet(Player.x, Player.y, "eBullet", "sin", 80, Player.angle * 180 / Math.PI, 2, 3);
                createBullet(Player.x, Player.y, "eBullet", "repl", 80, Player.angle * 180 / Math.PI, 2, 1);
                setTimeout(function () { Player.attackCool = 0 }, deltaTime * 60 * 66);
            }
        }

        function draw()
        {
            //Canvas
            Context.fillStyle = '#FFFFFF';
            Context.fillRect(0, 0, Canvas.width, Canvas.height);
            //Box
            Context.strokeStyle = '#000000';
            Context.strokeRect(1, 1, Canvas.width - 2, Canvas.height - 2);

            //tap
            Context.fillStyle = "#CCCCCC";
            Context.fillRect(Canvas.width * tapCorrection, Canvas.height * tapCorrection, Canvas.width * (1 - 2 * tapCorrection), Canvas.height * (1 - 2 * tapCorrection));
            Context.strokeRect(Canvas.width * tapCorrection, Canvas.height * tapCorrection, Canvas.width * (1 - 2 * tapCorrection), Canvas.height * (1 - 2 * tapCorrection));
            Context.fillStyle = "#000000";
            Context.globalAlpha = 0.7;
            Context.font = "48px serif";
            Context.fillText(System.CurrentTap, Canvas.width/2-14, Canvas.height/2+16);
            Context.globalAlpha = 1;

            //Link(door)
            for (var i = 0; i < 4; i++) {
                if (Taps[System.CurrentTap].Links[i] != -1)
                {
                    if (Taps[Taps[System.CurrentTap].Links[i]].TapType == "Start") { Context.strokeStyle = "#0000FF"; }
                    else if (Taps[Taps[System.CurrentTap].Links[i]].TapType == "Boss") { Context.strokeStyle = "#FF0000"; }
                    else { Context.strokeStyle = "#000000" }
                    drawCircle(Link[i].x, Link[i].y, Link[i].size, 0, Math.PI * 2, false);
                    Context.strokeStyle = "#000000"
                    Link[i].active = true;
                }
            }

            //Bullets
            var ball;
            for (var i = 0; i < Ebullet.length; i++)
            {
                ball = Ebullet[i];
                if (ball.bulletType == "sin")
                {
                    goSinbullet(ball);
                    drawCircle(ball.x, ball.y, ball.size, 0, Math.PI * 2, true);
                }
                else if (ball.bulletType == "repl") {
                    goReflectbullet(ball);
                    drawCircle(ball.x, ball.y, ball.size, 0, Math.PI * 2, true);
                }
                else if (ball.bulletType == "big") {
                    goBigbullet(ball);
                    drawCircle(ball.x, ball.y, ball.size*10, 0, Math.PI * 2, true);
                }
                else if (ball.bulletType == "lazer") {
                    goLazerbullet(ball);
                    drawRect(ball.x, ball.y, ball.size*2, ball.size, true);
                }
            }

            //walls
            Context.strokeStyle = "#000000";
            Context.fillStyle = "#00FF00";
            for (var i = 0; i < Objects.length; i++)
            {
                var wall = Objects[i];
                console.log(wall);
                drawRect(wall.x, wall.y, wall.w, wall.h, true);
            }
            Context.strokeStyle = "#000000";
            Context.fillStyle = "#000000";


            //Enemy


            //Player
            if (Player.dx != 0 || Player.dy != 0) {
                if (Player.dx > 1) Player.dx = 1;
                if (Player.dy < -1) Player.dx = -1;
                if (Player.dy > 1) Player.dy = 1;
                if (Player.dy < -1) Player.dy = -1;
                var dx = Player.dx / Math.sqrt(Player.dx * Player.dx + Player.dy * Player.dy);
                var dy = Player.dy / Math.sqrt(Player.dx * Player.dx + Player.dy * Player.dy);
                Player.x += dx * Player.speed * deltaTime;
                Player.y += dy * Player.speed * deltaTime;
            }
            drawCircle(Player.x, Player.y, Player.size, 0, Math.PI * 2, true);

            //Cursor & Triangle
            Context.strokeStyle = '#000000';
            var cLeng = 5;
            Context.beginPath();
            Context.moveTo(Cursor.x + cLeng, Cursor.y);
            Context.lineTo(Cursor.x - cLeng, Cursor.y);
            Context.stroke();
            Context.moveTo(Cursor.x, Cursor.y + cLeng);
            Context.lineTo(Cursor.x, Cursor.y - cLeng);
            Context.stroke();
            Context.closePath();

            Context.fillStyle = "#FF0000";
            Player.angle = -Math.atan2((Cursor.y - Player.y), (Cursor.x - Player.x));
            var distPT = Player.size + Cursor.size;
            Context.beginPath();
            Context.moveTo(Player.x + distPT * Math.cos(Player.angle), Player.y - distPT * Math.sin(Player.angle));
            Context.lineTo(Player.x + (distPT - Cursor.size * Math.sqrt(3) / 2) * Math.cos(Player.angle) + (-Cursor.size / 2) * Math.sin(Player.angle), Player.y - (distPT - Cursor.size * Math.sqrt(3) / 2) * Math.sin(Player.angle) + (-Cursor.size / 2) * Math.cos(Player.angle));
            Context.lineTo(Player.x + (distPT - Cursor.size * Math.sqrt(3) / 2) * Math.cos(Player.angle) + (Cursor.size / 2) * Math.sin(Player.angle), Player.y - (distPT - Cursor.size * Math.sqrt(3) / 2) * Math.sin(Player.angle) + (Cursor.size / 2) * Math.cos(Player.angle));
            Context.closePath();
            Context.fill();

            //map
            Context.globalAlpha = 0.5;
            Context.fillStyle = "#CCCCCC";
            var miniMap = { x: 10, y: 10, w: 150, h: 150, size: 10 };
            Context.fillRect(miniMap.x, miniMap.y, miniMap.w, miniMap.h);
            Context.globalAlpha = 0.5;
            Context.lineWidth = 0.8;
            for (var i = 0; i < Taps.length; i++)
            {
                Context.strokeStyle = "#000000";
                for (var j = 0; j < 4; j++)
                {
                    if (Taps[i].Links[j] != -1)
                    {
                        Context.beginPath();
                        Context.moveTo(miniMap.x + miniMap.w / 2 + Taps[i].x * 2 * miniMap.size, miniMap.y + miniMap.h / 2 + Taps[i].y * 2 * miniMap.size);
                        switch (j)
                        {
                            case 0: Context.lineTo(miniMap.x + miniMap.w / 2 + Taps[i].x * 2 * miniMap.size, miniMap.y + miniMap.h / 2 + Taps[i].y * 2 * miniMap.size + miniMap.size); break;
                            case 1: Context.lineTo(miniMap.x + miniMap.w / 2 + Taps[i].x * 2 * miniMap.size + miniMap.size, miniMap.y + miniMap.h / 2 + Taps[i].y * 2 * miniMap.size); break;
                            case 2: Context.lineTo(miniMap.x + miniMap.w / 2 + Taps[i].x * 2 * miniMap.size, miniMap.y + miniMap.h / 2 + Taps[i].y * 2 * miniMap.size - miniMap.size); break;
                            case 3: Context.lineTo(miniMap.x + miniMap.w / 2 + Taps[i].x * 2 * miniMap.size - miniMap.size, miniMap.y + miniMap.h / 2 + Taps[i].y * 2 * miniMap.size); break;
                        }
                        Context.stroke();
                        Context.closePath();
                    }
                }
                Context.globalAlpha = 0.9;
                if (Taps[i].TapType == "Start") { Context.fillStyle = "#0000FF"; }
                else { Context.fillStyle = "#000000"; }
                if (i == System.CurrentTap) { Context.fillStyle = "#FF0000"; }

                if (Taps[i].TapType == "Boss")
                {
                    Context.fillRect(miniMap.x + miniMap.w / 2 - miniMap.size / 2 + Taps[i].x * 2 * miniMap.size, miniMap.y + miniMap.h / 2 - miniMap.size / 2 + Taps[i].y * 2 * miniMap.size, miniMap.size, miniMap.size);
                }
                else
                {
                    Context.fillRect(miniMap.x + miniMap.w / 2 - miniMap.size * 1 / 3 + Taps[i].x * 2 * miniMap.size, miniMap.y + miniMap.h / 2 - miniMap.size * 1 / 3 + Taps[i].y * 2 * miniMap.size, miniMap.size * 2 / 3, miniMap.size * 2 / 3);
                }
            }
            Context.lineWidth = 1;
            Context.globalAlpha = 1;
            Context.fillStyle = "#000000";
        }
        function moveToOtherTap(i)
        {
            System.CurrentTap = Taps[System.CurrentTap].Links[i];
            for (var j = 0; j < Taps.length; j++) {
                Taps[j].x = Taps[j].y = 0;
            }
            tapLocationSet(Taps, System.CurrentTap, 0, 0);
            for (var j = 0; j < Taps.length; j++) {
                Taps[j].check = 0;
            }
            for (var j = 0; j < 4; j++) {
                Link[j].active = false;
            }
            while (Ebullet.length > 0) {
                var ball = Ebullet[0];
                console.log(ball);
                Ebullet.pop(ball);
            }
            if (i == 0 || i == 2) {
                if (Player.y >= 300) { Player.y = 300 - (Player.y - 300) + 10; }
                else if (Player.y < 300) { Player.y = 300 - (Player.y - 300) - 10; }
            }
            else {
                if (Player.x >= 400) { Player.x = 400 - (Player.x - 400) + 10; }
                else if (Player.x < 400) { Player.x = 400 - (Player.x - 400) - 10; }
            }
        }
        function collision()
        {
            //Player and Wall
            for (var i = 0; i < Objects.length; i++)
            {
                if (collisionCirRec(Player, Objects[i]))
                {
                    alert("test");
                }
            }

            //Player and EBullet

            if (Taps[System.CurrentTap].Enemy == null) Taps[System.CurrentTap].clear = 1;
            if (Taps[System.CurrentTap].clear == 1) //Player and Link
            {
                for (var i = 0; i < 4; i++) {
                    if (Link[i].active == true && collisionCirCir(Player, Link[i])) {
                        moveToOtherTap(i);
                    }
                }
            }
            else
            {
                //Player and Enemy

                //Enemy and Wall

                //Enemy and PBullet
            }

            //PBullet and Wall
            //EBullet and Wall
        }
        function collisionCirCir(cir1, cir2) {
            var dx;
            var dy;
            var dr;
            dx = cir1.x - cir2.x;
            dy = cir1.y - cir2.y;
            dr = cir1.size + cir2.size;
            dx = dx * dx;
            dy = dy * dy;
            dr = dr * dr;
            if (dr > dx + dy)
                return true;
            return false;
        }
        function collisionCirRec(cir, rec) {
            var check = false;
            if (cir.x > rec.x && cir.y > rec.y && cir.x < rec.x + rec.w && cir.y < rec.y + rec.h) { check = true; }
            else if ((rec.x - cir.x) * (rec.x - cir.x) + (rec.y - cir.y) * (rec.y - cir.y) < cir.size * cir.size) { check = true; }
            else if ((rec.x + rec.w - cir.x) * (rec.x + rec.w - cir.x) + (rec.y - cir.y) * (rec.y - cir.y) < cir.size * cir.size) { check = true; }
            else if ((rec.x - cir.x) * (rec.x - cir.x) + (rec.y + rec.h - cir.y) * (rec.y + rec.h - cir.y) < cir.size * cir.size) { check = true; }
            else if ((rec.x + rec.w - cir.x) * (rec.x + rec.w - cir.x) + (rec.y + rec.h - cir.y) * (rec.y + rec.h - cir.y) < cir.size * cir.size) { check = true; }
            else if (cir.y > rec.y && cir.y < rec.y + rec.h && rec.x - cir.x < cir.size) { check = true; }
            else if (cir.x > rec.x && cir.x < rec.x + rec.w && rec.y - cir.y < cir.size) { check = true; }
            else if (cir.y > rec.y && cir.y < rec.y + rec.h && cir.x - (rec.x + rec.w) < cir.size) { check = true; }
            else if (cir.x > rec.x && cir.x < rec.x + rec.w && cir.y - (rec.y + rec.h) < cir.size) { check = true; }
            return check;
        }

        function createBullet(Bx, By, Btype, BbulletType, Bspeed, Bangle, Bsize, Bspacial)
        {
            var tempBall = { type: Btype, bulletType: BbulletType, x: Bx, y: By, angle: Bangle, speed: Bspeed, size: Bsize, dx: 0, dy: 0, bs: Bspacial }
            if (tempBall.bulletType == "sin")
            {
                tempBall.dx = tempBall.x;
                tempBall.dy = tempBall.y;
            }
            if (tempBall.x > Canvas.width || tempBall.x < 0 || tempBall.y > Canvas.height || tempBall.y < 0) {
                return;
            }

            if (tempBall.type == "eBullet")
            {
                Ebullet.push(tempBall);
            }
            else if (tempBall.type == "pBullet") {
                Pbullet.push(tempBall);
            }
        }
        function goReflectbullet(ball) {
            var radians = -ball.angle * Math.PI / 180;
            ball.dx = Math.cos(radians);
            ball.dy = Math.sin(radians);

            ball.x += ball.dx * ball.speed * deltaTime;
            ball.y += ball.dy * ball.speed * deltaTime;
            if (ball.x > Canvas.width - ball.size || ball.x < ball.size) {
                ball.angle = 180 - ball.angle;
                ball.bs--;
            }
            if (ball.y > Canvas.height - ball.size || ball.y < ball.size) {
                ball.angle = 360 - ball.angle;
                ball.bs--;
            }
            if (ball.bs < 1) {
                Ebullet.splice(Ebullet.findIndex(function (item) { return item === ball }), 1);
            }
        }
        function goBigbullet(ball) {
            var radians = -ball.angle * Math.PI / 180;
            ball.dx = Math.cos(radians);
            ball.dy = Math.sin(radians);

            ball.x += ball.dx * ball.speed * deltaTime;
            ball.y += ball.dy * ball.speed * deltaTime;
            if (ball.x > Canvas.width - ball.size || ball.x < ball.size) {
                ball.angle = 180 - ball.angle;
                ball.bs--;
            }
            if (ball.y > Canvas.height - ball.size || ball.y < ball.size) {
                ball.angle = 360 - ball.angle;
                ball.bs--;
            }
            if (ball.bs < 1) {
                var smalls = 20;
                for (var i = 0; i < smalls; i++)
                {
                    createBullet(ball.x, ball.y, "eBullet", "repl", 80, -ball.angle + 360 / smalls * i, 2, 1);
                }
                Ebullet.splice(Ebullet.findIndex(function (item) { return item === ball }), 1);
            }
        }
        function goSinbullet(ball)
        {
            ball.speed = 20;
            var theta = -ball.angle;
            ball.x = ball.dx + ball.bs * Math.cos(theta * Math.PI / 180) - 10 * Math.sin(ball.bs * Math.PI / 180 * 5) * Math.sin(theta * Math.PI / 180);
            ball.y = ball.dy + ball.bs * Math.sin(theta * Math.PI / 180) + 10 * Math.sin(ball.bs * Math.PI / 180 * 5) * Math.cos(theta * Math.PI / 180);
            ball.bs += ball.speed * deltaTime;
            if (ball.x > Canvas.width - 1) {
                ball.x = ball.dx;
                ball.y = ball.dy;

            }
            if (ball.y > Canvas.height - 1) {
                ball.y = ball.dy;
                ball.x = ball.dx;
            }
            if (ball.x < 0) {
                ball.x = ball.dx;
                ball.y = ball.dy;
            }
            if (ball.y < 0) {
                ball.x = ball.dx;
                ball.y = ball.dy;
            }
        }
        function goLazerbullet(ball) {
            ball.x = ball.x + 1;
        }

        function createWindow(Taps)
        {
            createTap(Taps, 0, 0, -1);
            Taps[Taps.length - 1].TapType = "Boss";
            for (var j = 0; j < Taps.length; j++) {
                Taps[j].x = Taps[j].y = 0;
            }
            tapLocationSet(Taps, 0, 0, 0);
            for (var i = 0; i < Taps.length; i++)
            {
                Taps[i].check = 0;
            }
        }
        function createTap(Taps, i, parentDirection, parentNum)
        {
            var tap;
            if (i == 0) {
                tap = { type: "Tap", TapType: "Start", Links: new Array(4), Enemy: null, clear: 1, check: 0, x: 0, y: 0 };
                Taps.push(tap);
                tap.Links[0] = tap.Links[1] = tap.Links[2] = tap.Links[3] = -1;
                tap.Links[parentDirection] = parentNum;
                for (var j = 0; j < 4; j++) {
                    if (tap.Links[j] == -1 && Taps.length < System.TapSize) {
                        var c = false;
                        var nx = tap.x;
                        var ny = tap.y;
                        switch (j) {
                            case 0: ny++; break;
                            case 1: nx++; break;
                            case 2: ny--; break;
                            case 3: nx--; break;
                        }
                        console.log("n:" + nx, ny);
                        for (var k = 0; k < Taps.length; k++) {
                            if (Taps[k].x == nx && Taps[k].y == ny) { c = true; }
                        }
                        if (c == true) { continue; }
                        tap.Links[j] = Taps.length;
                        createTap(Taps, Taps.length, (j + 2) % 4, i);
                    }
                }
            }
            else
            {
                tap = { type: "Tap", TapType: "Normal", Links: new Array(4), Enemy: null, clear: 0, check: 0, x: 0, y: 0 };
                Taps.push(tap);
                tap.Links[0] = tap.Links[1] = tap.Links[2] = tap.Links[3] = -1;
                tap.Links[parentDirection] = parentNum;
                tap.x = Taps[parentNum].x;
                tap.y = Taps[parentNum].y;
                switch (parentDirection) {
                    case 0: tap.y--; break;
                    case 1: tap.x--; break;
                    case 2: tap.y++; break;
                    case 3: tap.x++; break;
                }
                console.log("tap: " + tap.x, tap.y);
                for (var j = 0; j < 4; j++) {
                    if (tap.Links[j] == -1 && Taps.length < System.TapSize) {
                        var c = false;
                        var nx = tap.x;
                        var ny = tap.y;
                        switch (j) {
                            case 0: ny++; break;
                            case 1: nx++; break;
                            case 2: ny--; break;
                            case 3: nx--; break;
                        }
                        console.log("n:" + nx, ny);
                        for (var k = 0; k < Taps.length; k++) {
                            if (Taps[k].x == nx && Taps[k].y == ny) { c = true; }
                        }
                        if (c == true) { continue; }
                        if (Math.random() < (Taps.length) / (System.TapSize * parentNum))
                        {
                            tap.Links[j] = Taps.length;
                            createTap(Taps, Taps.length, (j + 2) % 4, i);
                            //var nTap = createTap(Taps, Taps.length);
                        }
                    }
                }
            }
            console.log(i, tap);
            return tap;
        }
        function tapLocationSet(Taps, tapIdx, dx, dy)
        {
            if (tapIdx > Taps.length || tapIdx < 0) { return; }
            var tap = Taps[tapIdx];
            console.log(tap);
            if (tap.check == 1) { return; }
            console.log(tapIdx + " tap: " + Taps.indexOf(tap));
            tap.x = dx;
            tap.y = dy;
            tap.check = 1;

            tapLocationSet(Taps, tap.Links[0], tap.x, tap.y + 1);
            tapLocationSet(Taps, tap.Links[1], tap.x + 1, tap.y);
            tapLocationSet(Taps, tap.Links[2], tap.x, tap.y - 1);
            tapLocationSet(Taps, tap.Links[3], tap.x - 1, tap.y);
        }

        var attcking = 0;
        function onKeyDownFunc(e)
        {
            e.stopPropagation();
            //alert(Player.dy);
            if (e.keyCode == 87 && Player.dy > -1)   //W
            {
                Player.dy--;
                if (Player.dy == 0) setTimeout(onKeyDownFunc(e), 1);
            }
            if (e.keyCode == 65 && Player.dx > -1)    //A
            {
                Player.dx--;
                if (Player.dx == 0) setTimeout(onKeyDownFunc(e), 1);
            }
            if (e.keyCode == 83 && Player.dy < 1)   //S
            {
                Player.dy++;
                if (Player.dy == 0) setTimeout(onKeyDownFunc(e), 1);
            }
            if (e.keyCode == 68 && Player.dx < 1)   //D
            {
                Player.dx++;
                if (Player.dx == 0) setTimeout(onKeyDownFunc(e), 1);
            }

            if (e.keyCode == 32) {
                attcking = 1;
            }
        }
        function onKeyPressFunc(e) {
            e.stopPropagation();
        }
        function onKeyUpFunc(e) {
            e.preventDefault();
            e.stopPropagation();
            //alert(e.keyCode);
            if (e.keyCode == 87 && Player.dy < 1)   //W
            {
                Player.dy = 0;
            }
            if (e.keyCode == 65 && Player.dx < 1)    //A
            {
                Player.dx = 0;
            }
            if (e.keyCode == 83 && Player.dy > -1)   //S
            {
                Player.dy = 0;
            }
            if (e.keyCode == 68 && Player.dx > -1)   //D
            {
                Player.dx = 0;
            }

            if (e.keyCode == 32) {
                attcking = 0;
            }
        }
        function onMouseMoveFunc(e) {
            e.preventDefault();
            e.stopPropagation();

            var rect = Canvas.getBoundingClientRect();
            Cursor.x = e.clientX - rect.left;
            Cursor.y = e.clientY - rect.top;
        }

        function drawCircle(x, y, r, sa, ea, f) {
            Context.beginPath();
            Context.arc(x, y, r, sa, ea, true);
            Context.closePath();
            if (f == true) {
                Context.fill();
            }
            else {
                Context.stroke();
            }
        }
        function drawRect(x, y, w, h, f) {
            Context.beginPath();
            Context.rect(x - w / 2, y - h / 2, w, h);
            Context.closePath();
            if (f == true) {
                Context.fill();
            }
            else {
                Context.stroke();
            }
        }
    }

    </script>

</head>
<body bgColor="black">
    <div id="container" style="position: absolute; top: 20px; left: 50px;">
        <canvas id="canvas" width="800" height="600">
            Your browser does not support the HTML 5 Canvas.
        </canvas>
    </div>
</body>
</html>