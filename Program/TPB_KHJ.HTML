<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <style type="text/css">
        @font-face {
            font-family: 'Product Sans';
            src: url('Resource/Product_Sans_Regular.ttf');
        }
    </style>
    <script type="text/javascript">
        window.addEventListener('load', game, false);
        //window.addEventListener('load', menu, false);
    function menu() {
        document.onkeydown = onKeyDownToStart;
        var Canvas = document.getElementById('canvas');
        var Context = Canvas.getContext('2d');
        document.getElementById('container').style.left = window.innerWidth / 2 - 400 + 'px';

        Context.globalCompositeOperation = "source-over";
        Context.fillStyle = '#FFFFFF';
        Context.strokeStyle = '#FFFFFF';
        Context.font = "48px Product Sans";

        setTimeout(menuDraw, 1 / 60);
        var theta = 0;
        var size = 160;
        var start = 0;
        var click = 0;
        function menuDraw() {
            Context.clearRect(0, 0, Canvas.width, Canvas.height);
            Context.strokeRect(3, 3, Canvas.width - 6, Canvas.height - 6);
            Context.fillStyle = '#FFFFFF';
            Context.globalCompositeOperation = "source-over";
            var s = size;
            var t = theta;
            var x = Canvas.width / 2;
            var y = Canvas.height / 3;
            Context.setTransform(1, 0, 0, 1, 0, 0);
            Context.translate(x + Math.cos(Math.PI / 180 * (135 - t)) * s * Math.sqrt(2) / 2, y + Math.sin(Math.PI / 180 * (135 - t)) * s * Math.sqrt(2) / 2);
            Context.rotate(-t * Math.PI / 180);
            Context.fillRect(0, 0, s, -s);
            Context.setTransform(1, 0, 0, 1, 0, 0);
            t = -t;
            Context.translate(x + Math.cos(Math.PI / 180 * (135 - t)) * s * Math.sqrt(2) / 2, y + Math.sin(Math.PI / 180 * (135 - t)) * s * Math.sqrt(2) / 2);
            Context.rotate(-t * Math.PI / 180);
            Context.fillRect(0, 0, s, -s);
            Context.setTransform(1, 0, 0, 1, 0, 0);
            for (var i = 0; i < 36; i++) {
                s += 8 + i;
                t *= -0.99;
                if (s < 0) continue;
                if (theta / 4 <= i) break;
                Context.translate(x + Math.cos(Math.PI / 180 * (135 - t)) * s * Math.sqrt(2) / 2, y + Math.sin(Math.PI / 180 * (135 - t)) * s * Math.sqrt(2) / 2);
                Context.rotate(-t * Math.PI / 180);
                Context.strokeRect(0, 0, s, -s);
                //Context.fillRect(0, 0, s, -s);
                Context.setTransform(1, 0, 0, 1, 0, 0);
            }

            Context.globalCompositeOperation = "xor";
            Context.font = "48px Product Sans";
            Context.fillText("The", 310, 150);
            Context.fillText("Page", 310, 200);
            Context.fillText("Breaker.", 310, 250);
            Context.font = "24px Product Sans";
            if (click == 0) { Context.fillText("Click_Any_Key_to_Start_The_Game", 10, 580); }
            else { Context.fillText("Now_Starting...", 10, 580); }
            theta += 0.00025*s;

            Context.globalCompositeOperation = "source-over";
            if (s > -256) { setTimeout(menuDraw, 1 / 60); }
            else { size = 0; start = 1; }
        }
        function onKeyDownToStart() {
            if (click == 0) {
                click = 1;
                gameStart();
            }
        }
        function gameStart() {
            if (start == 0) { size -= 1; setTimeout(gameStart, 1 / 60); }
            else if (start == 1) {
                size += 1 / 300;
                Context.fillStyle = '#FFFFFF';
                Context.fillRect(0, 0, Canvas.width, Canvas.height);
                Context.fillStyle = '#000000';
                Context.fillText("Now_Starting...", 10, 580);
                Context.fillRect(Canvas.width / 2 - (Canvas.width * 13 / 30) * size, Canvas.height / 2 - (Canvas.height * 13 / 30) * size, Canvas.width * 13 / 15 * size, Canvas.height * 13 / 15 * size);
                if (size >= 1) { start = 2;  }
                setTimeout(gameStart, 1 / 60);
            }
            else { setTimeout(game, 10); }
        }
    }
    function game() {
        document.onkeydown = onKeyDownFunc;
        document.onkeyup = onKeyUpFunc;
        document.onmousemove = onMouseMoveFunc;
        document.onmousedown = onMouseDownFunc;
        document.onmouseup = onMouseUpFunc;
        var Canvas = document.getElementById('canvas');
        var Context = Canvas.getContext('2d');
        document.getElementById('container').style.left = window.innerWidth / 2 - 400 + 'px';

        var frame = 60;
        var deltaTime = 1 / frame;

        var System = { Game: 0, Pause: 0, Life: 0, Bomb: 1, Score: 0, TapSize: 2, CurrentTap: 0 };

        var Taps = new Array();
        createWindow(Taps);
        var tapCorrection = 1 / 15;
        var Link = new Array();
        var linkWeight = 6.5;
        for (var i = 0; i < 4; i++) {
            var links = { type: "link", x: Canvas.width / 2, y: Canvas.height / 2, size: 30, linkDir: 0, effectx: new Array(), effecty: new Array(), active: false };
            switch (i) {
                case 0: links.y += Canvas.height * tapCorrection * linkWeight; break;
                case 1: links.x += Canvas.width * tapCorrection * linkWeight; break;
                case 2: links.y -= Canvas.height * tapCorrection * linkWeight; break;
                case 3: links.x -= Canvas.width * tapCorrection * linkWeight; break;
            }
            Link.push(links);
        }
        for (var j = 0; j < 4; j++) {
            for (var i = 0; i < 20; i++) {
                Link[j].effectx.push(Math.random() * 2.5 - 1.25);
                Link[j].effecty.push(Math.random() * 1.5 - 0.75);
            }
            Link[j].linkDir = Math.random() * 30 - 15;
        }

        var Objects = new Array();
        var wallWeight = 7;
        for (var i = 0; i < 4; i++) {
            var walls = { type: "wall", x: Canvas.width / 2, y: Canvas.height / 2, w: Canvas.width, h: Canvas.height };
            switch (i) {
                case 0: walls.y += Canvas.height * tapCorrection * wallWeight; walls.h *= tapCorrection; break;
                case 1: walls.x += Canvas.width * tapCorrection * wallWeight; walls.w *= tapCorrection; break;
                case 2: walls.y -= Canvas.height * tapCorrection * wallWeight; walls.h *= tapCorrection; break;
                case 3: walls.x -= Canvas.width * tapCorrection * wallWeight; walls.w *= tapCorrection; break;
            }
            Objects.push(walls);
        }

        var Player = { type: "player", x: 400, y: 300, angle: 0, speed: 40, size: 8, dx: 0, dy: 0, attackCool: 0, attackPower: 1, active: 1 };
        var Cursor = { type: "player", x: 0, y: 0, angle: 0, size: 10 };
        var Pbullet = new Array();
        var Ebullet = new Array();

        var eBulletNum = 10;
        var tempBall;
        for (var i = 0; i < eBulletNum; i++) {
            var tempAngle = Math.floor(Math.random() * 360);
            tempBall = { type: "eBullet", bulletType: "repl", x: 400, y: 200, angle: tempAngle, speed: 30, size: 5, dx: 400, dy: 200, bs: 5 }
            Ebullet.push(tempBall);
        }
        Ebullet[0].bulletType = "sin";

        setTimeout(update, deltaTime);
        function update() {
            //Pattack
            if (Player.active == 1 && Player.attackCool == 0 && (attcking1 == 1 || attcking2 == 1)) {
                Player.attackCool = 1;
                createBullet(Player.x, Player.y, "pBullet", "repl", 80, Player.angle * 180 / Math.PI, 2, 1);
                setTimeout(function () { Player.attackCool = 0 }, deltaTime * 60 * 66);
            }
            //Eattack
            for (var i = 0; i < Taps[System.CurrentTap].Enemy.length; i++) {
                if (Taps[System.CurrentTap].Enemy[i].enemyType == "square1")
                    emoving1(Taps[System.CurrentTap].Enemy[i]);
                if (Taps[System.CurrentTap].Enemy[i].enemyType == "square2")
                    emoving1(Taps[System.CurrentTap].Enemy[i]);
                if (Taps[System.CurrentTap].Enemy[i].enemyType == "square5")
                    emoving3(Taps[System.CurrentTap].Enemy[i]);
            }

            collision();
            draw();

            //check GameOver
            if (System.Life >= 0) { setTimeout(update, deltaTime);  }
            else { gameOver(Player.x, Player.y, System.Score); }
        }

        function draw() {
            //Canvas
            Context.fillStyle = '#000000';
            Context.fillRect(0, 0, Canvas.width, Canvas.height);
            Context.strokeStyle = '#FFFFFF';
            Context.strokeRect(0, 0, Canvas.width, Canvas.height);

            //tap
            Context.fillStyle = "#000000";
            Context.strokeStyle = '#000000';
            Context.fillRect(Canvas.width * tapCorrection, Canvas.height * tapCorrection, Canvas.width * (1 - 2 * tapCorrection), Canvas.height * (1 - 2 * tapCorrection));
            Context.strokeRect(Canvas.width * tapCorrection, Canvas.height * tapCorrection, Canvas.width * (1 - 2 * tapCorrection), Canvas.height * (1 - 2 * tapCorrection));
            Context.fillStyle = "#FFFFFF";
            Context.globalAlpha = 0.6;
            Context.font = "Bold 1000px Product Sans";
            //Context.fillText(System.CurrentTap, Canvas.width / 2 - 14, Canvas.height / 2 + 16);
            Context.fillText(System.CurrentTap * 3, Canvas.width / 5, Canvas.height / 2);
            Context.font = "2000px Product Sans";
            Context.fillText(System.CurrentTap * 7, -Canvas.width / 4, Canvas.height* 7 / 3);
            Context.font = "3000px Product Sans";
            Context.fillText(System.CurrentTap, -Canvas.width / 2, Canvas.height * 3 / 2);
            Context.font = "Bold 24px Product Sans";
            if (System.CurrentTap == 0)
            {
                Context.fillStyle = "#FFFF00";
                Context.fillText("Move: WASD", 100, 100);
                Context.fillText("Attack: Space or MouseLeft", 100, 500);
                Context.fillText("Slow: Shift", 600, 100);
                Context.fillText("Bomb: V", 600, 500);
            }
            Context.globalAlpha = 1;

            //walls
            Context.strokeStyle = "#FFFFFF";
            Context.fillStyle = "#FFFFFF";
            for (var i = 0; i < Objects.length; i++) {
                var wall = Objects[i];
                drawRect(wall.x, wall.y, wall.w, wall.h, true);
            }
            Context.globalAlpha = 1;
            Context.strokeStyle = "#000000";
            var wallEdge = 2;
            Context.strokeRect(wallEdge, wallEdge, Canvas.width - 2 * wallEdge, Canvas.height - 2 * wallEdge);
            Context.strokeRect(Canvas.width * tapCorrection - wallEdge, Canvas.height * tapCorrection - wallEdge, Canvas.width * tapCorrection * 13 + 2 * wallEdge, Canvas.height * tapCorrection * 13 + 2 * wallEdge);
            Context.strokeStyle = "#FFFFFF";

            //Link(door)
            if (Taps[System.CurrentTap].clear == 1) {
                for (var i = 0; i < 4; i++) {
                    if (Taps[System.CurrentTap].Links[i] != -1) {
                        if (Taps[Taps[System.CurrentTap].Links[i]].TapType == "Boss") { Context.strokeStyle = "#FF0000"; }
                        else { Context.strokeStyle = "#00EEFF" }
                        Context.globalAlpha = 1;
                        Context.clearRect(Link[i].x - Link[i].size / 3, Link[i].y - Link[i].size / 3, Link[i].size * 2 / 3, Link[i].size * 2 / 3);
                        Context.beginPath();
                        Context.moveTo(Link[i].x, Link[i].y);
                        Context.lineWidth = 2;
                        switch(i) {
                            case 0: Context.lineTo(Link[i].x + Link[i].linkDir, Link[i].y + 100); break;
                            case 1: Context.lineTo(Link[i].x + 100, Link[i].y + Link[i].linkDir); break;
                            case 2: Context.lineTo(Link[i].x + Link[i].linkDir, Link[i].y - 100); break;
                            case 3: Context.lineTo(Link[i].x - 100, Link[i].y + Link[i].linkDir); break;
                        }
                        Context.stroke();
                        Context.closePath();
                        Context.lineWidth = 1;
                        
                        for (var j = 0; j < Link[i].size; j++) {
                            drawCircle(Link[i].x, Link[i].y, j, 0, Math.PI * 2, false);
                            Context.globalAlpha -= 1 / Link[i].size;
                        }
                        Context.globalAlpha = 0.5;
                        Context.fillStyle = "#000000"
                        for (var j = 0; j < Link[i].size; j++) {
                            drawRect(Link[i].x + Link[i].size * Link[i].effectx[j], Link[i].y + Link[i].size * Link[i].effecty[j], Link[i].size / 2, Link[i].size / 4, true);
                        }
                        Context.globalAlpha = 1;
                        Context.strokeStyle = "#FFFFFF"
                        Link[i].active = true;
                    }
                }
            }

            //Bullets
            var ball;
            Context.fillStyle = "#FF0000";
            for (var i = 0; i < Pbullet.length; i++) {
                ball = Pbullet[i];
                goReflectbullet(ball);
                drawCircle(ball.x, ball.y, ball.size, 0, Math.PI * 2, true);
            }
            for (var i = 0; i < Ebullet.length; i++) {
                ball = Ebullet[i];
                Context.fillStyle = "#00EEFF";
                if (ball.bulletType == "sin") {
                    goSinbullet(ball);
                    drawCircle(ball.x, ball.y, ball.size, 0, Math.PI * 2, true);
                }
                else if (ball.bulletType == "repl") {
                    goReflectbullet(ball);
                    drawCircle(ball.x, ball.y, ball.size, 0, Math.PI * 2, true);
                }
                else if (ball.bulletType == "big") {
                    goBigbullet(ball);
                    drawCircle(ball.x, ball.y, ball.size, 0, Math.PI * 2, true);    //평균의 6~8배 크기
                    Context.fillStyle = "#000000";
                    drawCircle(ball.x, ball.y, ball.size * 0.9, 0, Math.PI * 2, true);
                }
                else if (ball.bulletType == "lazer") {
                    goLazerbullet(ball);
                    drawRect(ball.x, ball.y, ball.size*2, ball.size, true);
                }
            }

            //Player
            if (Player.active == 0) { Context.globalAlpha = 0.5; }
            if (Player.dx != 0 || Player.dy != 0) {
                if (Player.dx > 1) Player.dx = 1;
                if (Player.dy < -1) Player.dx = -1;
                if (Player.dy > 1) Player.dy = 1;
                if (Player.dy < -1) Player.dy = -1;
                var dx = Player.dx / Math.sqrt(Player.dx * Player.dx + Player.dy * Player.dy);
                var dy = Player.dy / Math.sqrt(Player.dx * Player.dx + Player.dy * Player.dy);
                if (slowMove == 0) { Player.speed = 40; }
                else { Player.speed = 20; }
                Player.x += dx * Player.speed * deltaTime;
                Player.y += dy * Player.speed * deltaTime;
            }
            Context.fillStyle = "#000000";
            drawCircle(Player.x, Player.y, Player.size, 0, Math.PI * 2, true);
            Context.strokeStyle = "#FF0000";
            drawCircle(Player.x, Player.y, Player.size, 0, Math.PI * 2, false);

            //Triangle & Cursor
            Context.fillStyle = "#FF0000";
            Player.angle = -Math.atan2((Cursor.y - Player.y), (Cursor.x - Player.x));
            var distPT = Player.size + Cursor.size;
            Context.beginPath();
            Context.moveTo(Player.x + distPT * Math.cos(Player.angle), Player.y - distPT * Math.sin(Player.angle));
            Context.lineTo(Player.x + (distPT - Cursor.size * Math.sqrt(3) / 2) * Math.cos(Player.angle) + (-Cursor.size / 2) * Math.sin(Player.angle), Player.y - (distPT - Cursor.size * Math.sqrt(3) / 2) * Math.sin(Player.angle) + (-Cursor.size / 2) * Math.cos(Player.angle));
            Context.lineTo(Player.x + (distPT - Cursor.size * Math.sqrt(3) / 2) * Math.cos(Player.angle) + (Cursor.size / 2) * Math.sin(Player.angle), Player.y - (distPT - Cursor.size * Math.sqrt(3) / 2) * Math.sin(Player.angle) + (Cursor.size / 2) * Math.cos(Player.angle));
            Context.closePath(); Context.fill();

            Context.globalAlpha = 1;
            Context.fillStyle = "#FFFFFF";
            Context.strokeStyle = '#FFFFFF';
            var cLeng = 5;
            Context.beginPath();
            Context.moveTo(Cursor.x + cLeng, Cursor.y);
            Context.lineTo(Cursor.x - cLeng, Cursor.y);
            Context.stroke();
            Context.moveTo(Cursor.x, Cursor.y + cLeng);
            Context.lineTo(Cursor.x, Cursor.y - cLeng);
            Context.stroke(); Context.closePath();

            //Enemy
            for (var i = 0; i < Taps[System.CurrentTap].Enemy.length; i++) {
                var enemy = Taps[System.CurrentTap].Enemy[i];
                Context.fillStyle = "#000000";
                Context.strokeStyle = "rgb(" + (enemy.mhp - enemy.heart) / enemy.mhp * 255 + "," + enemy.heart / enemy.mhp * 255 + "," + enemy.heart / enemy.mhp * 255 + ")";
                Context.globalAlpha = 2;
                switch (enemy.enemyType) {
                    case "square1": drawRect(enemy.x, enemy.y, enemy.w, enemy.h, true); drawRect(enemy.x, enemy.y, enemy.w, enemy.h, false); break;
                    case "square2": drawRhombus(enemy.x, enemy.y, enemy.w, enemy.h, true); break;
                    case "square3": drawRect(enemy.x, enemy.y, enemy.w, enemy.h, true); break;
                    case "square4": drawRhombus(enemy.x, enemy.y, enemy.w, enemy.h, true); break;
                    case "square5": { drawRect(enemy.x, enemy.y, enemy.w, enemy.h, true); drawTri(enemy.x - enemy.w/2, enemy.y-enemy.h/2, enemy.w, enemy.h, true); } break;
                    case "squareBoss": {
                        var gap = 2;
                        Context.fillStyle = "#000000";
                        Context.strokeStyle = "#000000";
                        Context.lineWidth = 5;
                        if (enemy.parts[0] == 1) { Context.beginPath(); Context.moveTo(enemy.x, enemy.y); Context.lineTo(enemy.x - enemy.leg, enemy.y - enemy.leg); Context.closePath(); Context.stroke(); }
                        if (enemy.parts[1] == 1) { Context.beginPath(); Context.moveTo(enemy.x, enemy.y); Context.lineTo(enemy.x - enemy.leg, enemy.y); Context.closePath(); Context.stroke(); }
                        if (enemy.parts[2] == 1) { Context.beginPath(); Context.moveTo(enemy.x, enemy.y); Context.lineTo(enemy.x - enemy.leg, enemy.y + enemy.leg); Context.closePath(); Context.stroke(); }
                        if (enemy.parts[3] == 1) { Context.beginPath(); Context.moveTo(enemy.x, enemy.y); Context.lineTo(enemy.x, enemy.y - enemy.h); Context.closePath(); Context.stroke(); }
                        if (enemy.parts[4] == 1) { Context.beginPath(); Context.moveTo(enemy.x, enemy.y); Context.lineTo(enemy.x, enemy.y + enemy.h); Context.closePath(); Context.stroke(); }
                        if (enemy.parts[5] == 1) { Context.beginPath(); Context.moveTo(enemy.x, enemy.y); Context.lineTo(enemy.x + enemy.leg, enemy.y - enemy.leg); Context.closePath(); Context.stroke(); }
                        if (enemy.parts[6] == 1) { Context.beginPath(); Context.moveTo(enemy.x, enemy.y); Context.lineTo(enemy.x + enemy.leg, enemy.y); Context.closePath(); Context.stroke(); }
                        if (enemy.parts[7] == 1) { Context.beginPath(); Context.moveTo(enemy.x, enemy.y); Context.lineTo(enemy.x + enemy.leg, enemy.y + enemy.leg); Context.closePath(); Context.stroke(); }
                        Context.fillStyle = "#FFFFFF";
                        Context.strokeStyle = "#000000";

                        if (enemy.parts[1] == 0) {
                            Context.lineWidth = 5;
                            Context.beginPath(); Context.moveTo(enemy.x, enemy.y); Context.lineTo(enemy.x - enemy.leg - enemy.w / 3, enemy.y); Context.closePath(); Context.stroke();
                            Context.lineWidth = 1;
                            drawRect(enemy.x - enemy.leg - enemy.w / 3, enemy.y, enemy.w / 3, enemy.h, true);
                            drawRect(enemy.x - enemy.leg - enemy.w / 3, enemy.y, enemy.w / 3 - gap, enemy.h - gap, false);
                        }
                        if (enemy.parts[3] == 0) {
                            Context.lineWidth = 5;
                            Context.beginPath(); Context.moveTo(enemy.x, enemy.y); Context.lineTo(enemy.x, enemy.y - enemy.leg - enemy.h / 3); Context.closePath(); Context.stroke();
                            Context.lineWidth = 1;
                            drawRect(enemy.x, enemy.y - enemy.leg - enemy.h / 3, enemy.w, enemy.h / 3, true);
                            drawRect(enemy.x, enemy.y - enemy.leg - enemy.h / 3, enemy.w - gap, enemy.h / 3 - gap, false);
                        }
                        if (enemy.parts[4] == 0) {
                            Context.lineWidth = 5;
                            Context.beginPath(); Context.moveTo(enemy.x, enemy.y); Context.lineTo(enemy.x, enemy.y + enemy.leg + enemy.h / 3); Context.closePath(); Context.stroke();
                            Context.lineWidth = 1;
                            drawRect(enemy.x, enemy.y + enemy.leg + enemy.h / 3, enemy.w, enemy.h / 3, true);
                            drawRect(enemy.x, enemy.y + enemy.leg + enemy.h / 3, enemy.w - gap, enemy.h / 3 - gap, false);
                        }
                        if (enemy.parts[6] == 0) {
                            Context.lineWidth = 5;
                            Context.beginPath(); Context.moveTo(enemy.x, enemy.y); Context.lineTo(enemy.x + enemy.leg + enemy.w / 3, enemy.y); Context.closePath(); Context.stroke();
                            Context.lineWidth = 1;
                            drawRect(enemy.x + enemy.leg + enemy.w / 3, enemy.y, enemy.w / 3, enemy.h, true);
                            drawRect(enemy.x + enemy.leg + enemy.w / 3, enemy.y, enemy.w / 3 - gap, enemy.h - gap, false);
                        }

                        Context.lineWidth = 1;
                        drawRect(enemy.x, enemy.y, enemy.w, enemy.h, true);
                        drawRect(enemy.x, enemy.y, enemy.w - gap, enemy.h - gap, false);
                        //Context.strokeStyle = "#00EEFF";
                        //drawRect(enemy.x, enemy.y, enemy.w, enemy.h, false);
                    } break;
                    case "squarePart": {
                        var gap = 2;
                        Context.fillStyle = "#000000";
                        Context.strokeStyle = "#FFFFFF";
                        drawRect(enemy.x, enemy.y, enemy.w, enemy.h, true);
                        drawRect(enemy.x, enemy.y, enemy.w - gap, enemy.h - gap, false);
                    } break;
                    case "squareBu": drawRect(enemy.x, enemy.y, enemy.w, enemy.h, true); break;
                }
            }

            //map
            Context.globalAlpha = 0.5;
            Context.fillStyle = "#555555";
            Context.strokeStyle = "#FFFFFF";
            var miniMap = { x: 10, y: 10, w: 150, h: 150, size: 10 };
            Context.fillRect(miniMap.x, miniMap.y, miniMap.w, miniMap.h);
            Context.globalAlpha = 0.9;
            Context.lineWidth = 0.8;
            for (var i = 0; i < Taps.length; i++) {
                if (Taps[i].x > 3 || Taps[i].x < -3 || Taps[i].y > 3 || Taps[i].y < -3) continue;
                if (i != System.CurrentTap && Taps[i].clear == 0) continue;
                for (var j = 0; j < 4; j++) {
                    if (Taps[i].Links[j] != -1) {
                        Context.beginPath();
                        Context.moveTo(miniMap.x + miniMap.w / 2 + Taps[i].x * 2 * miniMap.size, miniMap.y + miniMap.h / 2 + Taps[i].y * 2 * miniMap.size);
                        switch (j) {
                            case 0: Context.lineTo(miniMap.x + miniMap.w / 2 + Taps[i].x * 2 * miniMap.size, miniMap.y + miniMap.h / 2 + Taps[i].y * 2 * miniMap.size + miniMap.size); break;
                            case 1: Context.lineTo(miniMap.x + miniMap.w / 2 + Taps[i].x * 2 * miniMap.size + miniMap.size, miniMap.y + miniMap.h / 2 + Taps[i].y * 2 * miniMap.size); break;
                            case 2: Context.lineTo(miniMap.x + miniMap.w / 2 + Taps[i].x * 2 * miniMap.size, miniMap.y + miniMap.h / 2 + Taps[i].y * 2 * miniMap.size - miniMap.size); break;
                            case 3: Context.lineTo(miniMap.x + miniMap.w / 2 + Taps[i].x * 2 * miniMap.size - miniMap.size, miniMap.y + miniMap.h / 2 + Taps[i].y * 2 * miniMap.size); break;
                        }
                        Context.stroke(); Context.closePath();
                    }
                }
                if (i == System.CurrentTap) { Context.fillStyle = "#FF0000"; }
                else if (Taps[i].TapType == "Start") { Context.fillStyle = "#50bcdf"; }
                else { Context.fillStyle = "#FFFFFF"; }
                if (Taps[i].TapType == "Boss") {
                    Context.fillRect(miniMap.x + miniMap.w / 2 - miniMap.size / 2 + Taps[i].x * 2 * miniMap.size, miniMap.y + miniMap.h / 2 - miniMap.size / 2 + Taps[i].y * 2 * miniMap.size, miniMap.size, miniMap.size);
                }
                else {
                    Context.fillRect(miniMap.x + miniMap.w / 2 - miniMap.size * 1 / 3 + Taps[i].x * 2 * miniMap.size, miniMap.y + miniMap.h / 2 - miniMap.size * 1 / 3 + Taps[i].y * 2 * miniMap.size, miniMap.size * 2 / 3, miniMap.size * 2 / 3);
                }
            }
            Context.lineWidth = 1;
            Context.globalAlpha = 1;
        }
        function moveToOtherTap(i) {
            //miniMap set
            System.CurrentTap = Taps[System.CurrentTap].Links[i];
            for (var j = 0; j < Taps.length; j++) {
                Taps[j].x = Taps[j].y = 0;
            }
            tapLocationSet(Taps, System.CurrentTap, 0, 0);
            for (var j = 0; j < Taps.length; j++) {
                Taps[j].check = 0;
            }
            //link set
            for (var j = 0; j < 4; j++) {
                Link[j].active = false;
            }
            //erase bullets
            while (Ebullet.length > 0) {
                var ball = Ebullet[0];
                Ebullet.pop(ball);
            }
            while (Pbullet.length > 0) {
                var ball = Pbullet[0];
                Pbullet.pop(ball);
            }
            //move Player
            if (i == 0 || i == 2) {
                if (Player.y >= 300) { Player.y = 300 - (Player.y - 300) + 10; }
                else if (Player.y < 300) { Player.y = 300 - (Player.y - 300) - 10; }
            }
            else {
                if (Player.x >= 400) { Player.x = 400 - (Player.x - 400) + 10; }
                else if (Player.x < 400) { Player.x = 400 - (Player.x - 400) - 10; }
            }

            //Link effect
            for (var j = 0; j < 4; j++) {
                for (var i = 0; i < 15; i++) {
                    Link[j].effectx.pop();
                    Link[j].effecty.pop();
                }
                for (var i = 0; i < 15; i++) {
                    Link[j].effectx.push(Math.random() * 2.5 - 1.25);
                    Link[j].effecty.push(Math.random() * 1.5 - 0.75);
                }
                Link[j].linkDir = Math.random() * 30 - 15;
            }
        }
        var wallCheck = { up: 0, down: 0, left: 0, right: 0, cnt: 0 };
        function collision() {
            //Player and Wall
            var u, d, l, r;
            u = d = l = r = 0;
            wallCheck.cnt = 0;
            for (var i = 0; i < Objects.length; i++) {
                switch (collisionCirRec(Player, Objects[i])) {
                    case "UU": if (Player.dy == 1) u++; break;
                    case "DD": if (Player.dy == -1) d++; break;
                    case "LL": if (Player.dx == 1) l++; break;
                    case "RR": if (Player.dx == -1) r++; break;
                    case "LU": if (Player.dx == 1 && Player.dy == 1) { u++; l++; } break;
                    case "RU": if (Player.dx == -1 && Player.dy == 1) { u++; r++; } break;
                    case "LD": if (Player.dx == 1 && Player.dy == -1) { d++; l++; } break;
                    case "RD": if (Player.dx == -1 && Player.dy == -1) { d++; r++; } break;
                    default: wallCheck.cnt++;
                }
            }
            if (u != 0 && Player.dy == 1) { Player.dy = -Player.dy; }
            if (d != 0 && Player.dy == -1) { Player.dy = -Player.dy; }
            if (l != 0 && Player.dx == 1) { Player.dx = -Player.dx; }
            if (r != 0 && Player.dx == -1) { Player.dx = -Player.dx; }
            if (u == 0 && d == 0) {
                if (wallCheck.up != 0 || wallCheck.down != 0) { Player.dy = 0; }
            }
            if (l == 0 && r == 0) {
                if (wallCheck.left != 0 || wallCheck.right != 0) { Player.dx = 0; }
            }
            wallCheck.up = u;
            wallCheck.down = d;
            wallCheck.left = l;
            wallCheck.right = r;

            //Player and EBullet
            for (var i = 0; i < Ebullet.length; i++) {
                if (collisionCirCir(Player, Ebullet[i])) {
                    playerDie();
                }
            }

            //Player and Link
            if (Taps[System.CurrentTap].Enemy.length == 0) { Taps[System.CurrentTap].clear = 1; }
            if (Taps[System.CurrentTap].clear == 1) {
                for (var i = 0; i < 4; i++) {
                    if (Link[i].active == true && collisionCirCir(Player, Link[i])) {
                        moveToOtherTap(i);
                    }
                }
            }
            else {
                for (var j = 0; j < Taps[System.CurrentTap].Enemy.length; j++) {
                    //Enemy and Wall
                    for (var i = 0; i < Objects.length; i++) {
                        if (collisionCirRec(Taps[System.CurrentTap].Enemy[j], Objects[i]) != 'OUT') {
                            //Taps[System.CurrentTap].Enemy[j]
                        }
                    }

                    //Player and Enemy
                    var enemy = Taps[System.CurrentTap].Enemy[j];
                    if (enemy.enemyType == "square2" || enemy.enemyType == "square4") {
                        if (collisionCirCir(Player, enemy) == true) {
                            playerDie();
                        }
                    }
                    else {
                        if (collisionCirRec(Player, enemy) != "OUT") {
                            playerDie();
                        }
                    }
                    //Enemy and PBullet
                    for (var i = 0; i < Pbullet.length; i++) {
                        if (enemy.enemyType == "square2" || enemy.enemyType == "square4") {
                            if (collisionCirCir(Pbullet[i], enemy) == true) {
                                enemy.heart--;
                                Pbullet.splice(i, 1);
                            }
                        }
                        else {
                            if (collisionCirRec(Pbullet[i], enemy) != "OUT") {
                                enemy.heart--;
                                Pbullet.splice(i, 1);
                            }
                        }

                        if (enemy.heart <= 0) {
                            if (enemy.enemyType == "squarePart") {
                                if (enemy.x < enemy.parent.x) {
                                    if (enemy.y < enemy.parent.y) { enemy.parent.parts[0] = 0; }
                                    else if (enemy.y == enemy.parent.y) { enemy.parent.parts[1] = 0; }
                                    else { enemy.parent.parts[2] = 0; }
                                }
                                else if (enemy.x == enemy.parent.x) {
                                    if (enemy.y < enemy.parent.y) { enemy.parent.parts[3] = 0; }
                                    else { enemy.parent.parts[4] = 0; }
                                }
                                else {
                                    if (enemy.y < enemy.parent.y) { enemy.parent.parts[5] = 0; }
                                    else if (enemy.y == enemy.parent.y) { enemy.parent.parts[6] = 0; }
                                    else { enemy.parent.parts[7] = 0; }
                                }
                                
                            }
                            Taps[System.CurrentTap].Enemy.splice(Taps[System.CurrentTap].Enemy.findIndex(function (item) { return item === enemy }), 1);
                            break;
                            //아이템 떨구기
                            //적 수 확인
                            //클리어 판정
                            //스코어
                        }
                    }
                }
            }
            for (var j = 0; j < Objects.length; j++) {
                //PBullet and Wall
                for (var i = 0; i < Pbullet.length; i++) {
                    var col = collisionCirRec(Pbullet[i], Objects[j]);
                    if (col != "OUT") {
                        bulletWallCollision(Pbullet[i], Objects[j], col);
                    }
                }
                //EBullet and Wall
                for (var i = 0; i < Ebullet.length; i++) {
                    var col = collisionCirRec(Ebullet[i], Objects[j]);
                    if (col != "OUT") {
                        bulletWallCollision(Ebullet[i], Objects[j], col);
                    }
                }
            }
        }
        function collisionCirCir(cir1, cir2) {
            var dx = cir1.x - cir2.x; dx = dx * dx;
            var dy = cir1.y - cir2.y; dy = dy * dy;
            var dr = cir1.size + cir2.size; dr = dr * dr;
            if (dr > dx + dy) { return true; }
            return false;
        }
        function collisionCirRec(cir, rec) {
            var check = "OUT";
            var rect = { x: rec.x - rec.w / 2, y: rec.y - rec.h / 2, w: rec.w, h: rec.h };
            if (cir.x > rect.x && cir.y > rect.y && cir.x < rect.x + rect.w && cir.y < rect.y + rect.h) { check = "IN"; }
            else if ((rect.x - cir.x) * (rect.x - cir.x) + (rect.y - cir.y) * (rect.y - cir.y) < cir.size * cir.size) { check = "LU"; }
            else if ((rect.x + rect.w - cir.x) * (rect.x + rect.w - cir.x) + (rect.y - cir.y) * (rect.y - cir.y) < cir.size * cir.size) { check = "RU"; }
            else if ((rect.x - cir.x) * (rect.x - cir.x) + (rect.y + rect.h - cir.y) * (rect.y + rect.h - cir.y) < cir.size * cir.size) { check = "LD"; }
            else if ((rect.x + rect.w - cir.x) * (rect.x + rect.w - cir.x) + (rect.y + rect.h - cir.y) * (rect.y + rect.h - cir.y) < cir.size * cir.size) { check = "RD"; }
            else if (cir.y > rect.y && cir.y < rect.y + rect.h && rect.x - cir.x < cir.size && rect.x - cir.x > 0) { check = "LL"; }
            else if (cir.x > rect.x && cir.x < rect.x + rect.w && rect.y - cir.y > 0 && rect.y - cir.y < cir.size) { check = "UU"; }
            else if (cir.y > rect.y && cir.y < rect.y + rect.h && cir.x - (rect.x + rect.w) > 0 && cir.x - (rect.x + rect.w) < cir.size) { check = "RR"; }
            else if (cir.x > rect.x && cir.x < rect.x + rect.w && cir.y - (rect.y + rect.h) < cir.size && cir.y - (rect.y + rect.h) > 0) { check = "DD"; }
            return check;
        }
        function bulletWallCollision(ball, wall, dir) {
            if (ball.bulletType == "repl") {
                if (dir == "RR" || dir == "LL") {
                    ball.angle = 180 - ball.angle;
                    ball.bs--;
                }
                else if (dir == "UU" || dir == "DD") {
                    ball.angle = 360 - ball.angle;
                    ball.bs--;
                }
                if (ball.bs < 1) {
                    deleteBullet(ball);
                }
            }
            else if (ball.bulletType == "big") {
                if (collisionCirRec(ball, wall) == "IN") {
                    var smalls = 20;
                    for (var i = 0; i < smalls; i++) {
                        createBullet(ball.x, ball.y, "eBullet", "repl", ball.speed * 1.5, -ball.angle + 360 / smalls * i, 2, 1);
                    }
                    deleteBullet(ball);
                }
            }
            else { deleteBullet(ball); }
        }
        function deleteBullet(ball) {
            if (ball.type == "eBullet") {
                Ebullet.splice(Ebullet.findIndex(function (item) { return item === ball }), 1);
            }
            else if (ball.type == "pBullet") {
                Pbullet.splice(Pbullet.findIndex(function (item) { return item === ball }), 1);
            }
        }
        function createBullet(Bx, By, Btype, BbulletType, Bspeed, Bangle, Bsize, Bspacial) {
            var tempBall = { type: Btype, bulletType: BbulletType, x: Bx, y: By, angle: Bangle, speed: Bspeed, size: Bsize, dx: 0, dy: 0, bs: Bspacial }
            if (tempBall.bulletType == "sin") {
                tempBall.dx = Bx;
                tempBall.dy = By;
            }
            if (tempBall.x > Canvas.width || tempBall.x < 0 || tempBall.y > Canvas.height || tempBall.y < 0) { return; }

            if (tempBall.type == "eBullet") { Ebullet.push(tempBall); }
            else if (tempBall.type == "pBullet") { Pbullet.push(tempBall); }
        }
        function goReflectbullet(ball) {
            var radians = -ball.angle * Math.PI / 180;
            ball.dx = Math.cos(radians);
            ball.dy = Math.sin(radians);
            ball.x += ball.dx * ball.speed * deltaTime;
            ball.y += ball.dy * ball.speed * deltaTime;
            if (ball.x > Canvas.width + ball.size || ball.x < -ball.size || ball.y > Canvas.height + ball.size || ball.y < -ball.size) { deleteBullet(ball); }
        }
        function goBigbullet(ball) {
            var radians = -ball.angle * Math.PI / 180;
            ball.dx = Math.cos(radians);
            ball.dy = Math.sin(radians);
            ball.x += ball.dx * ball.speed * deltaTime;
            ball.y += ball.dy * ball.speed * deltaTime;
            if (ball.x > Canvas.width + ball.size || ball.x < -ball.size || ball.y > Canvas.height + ball.size || ball.y < -ball.size) { deleteBullet(ball); }
        }
        function goSinbullet(ball) {
            var theta = -ball.angle;
            ball.x = ball.dx + ball.bs * Math.cos(theta * Math.PI / 180) - 10 * Math.sin(ball.bs * Math.PI / 180 * 5) * Math.sin(theta * Math.PI / 180);
            ball.y = ball.dy + ball.bs * Math.sin(theta * Math.PI / 180) + 10 * Math.sin(ball.bs * Math.PI / 180 * 5) * Math.cos(theta * Math.PI / 180);
            ball.bs += ball.speed * deltaTime;
            if (ball.x > Canvas.width + ball.size || ball.x < -ball.size || ball.y > Canvas.height + ball.size || ball.y < -ball.size) { deleteBullet(ball); }
        }
        function goLazerbullet(ball) {
            ball.x = ball.x + 1;
            if (ball.x > Canvas.width + ball.size || ball.x < -ball.size || ball.y > Canvas.height + ball.size || ball.y < -ball.size) { deleteBullet(ball); }
        }

        function playerDie() {
            if (Player.active == 1) {
                Player.active = 0;
                System.Life--;
                if (System.Life >= 0) { setTimeout(respawn, 3000); }
            }
        }
        function respawn() { Player.active = 1; }
        function createWindow(Taps) {
            createTap(Taps, 0, 0, -1);
            Taps[Taps.length - 1].TapType = "Boss";
            var boss = makeEne(6, 400, 300);
            Taps[Taps.length - 1].Enemy.push(boss);
            for (var i = 0; i < 8; i++) { boss.parts[i] = 1; }
            var gap = 2;
            var part = makeEne(7, boss.x - boss.w / 3 - gap, boss.y - boss.h / 3 - gap);
            Taps[Taps.length - 1].Enemy.push(part); part.parent = boss;
            part = makeEne(7, boss.x - boss.w / 3 - gap, boss.y);
            Taps[Taps.length - 1].Enemy.push(part); part.parent = boss;
            part = makeEne(7, boss.x - boss.w / 3 - gap, boss.y + boss.h / 3 + gap);
            Taps[Taps.length - 1].Enemy.push(part); part.parent = boss;
            part = makeEne(7, boss.x, boss.y - boss.h / 3 - gap);
            Taps[Taps.length - 1].Enemy.push(part); part.parent = boss;
            part = makeEne(7, boss.x, boss.y + boss.h / 3 + gap);
            Taps[Taps.length - 1].Enemy.push(part); part.parent = boss;
            part = makeEne(7, boss.x + boss.w / 3 + gap, boss.y - boss.h / 3 - gap);
            Taps[Taps.length - 1].Enemy.push(part); part.parent = boss;
            part = makeEne(7, boss.x + boss.w / 3 + gap, boss.y);
            Taps[Taps.length - 1].Enemy.push(part); part.parent = boss;
            part = makeEne(7, boss.x + boss.w / 3 + gap, boss.y + boss.h / 3 + gap);
            Taps[Taps.length - 1].Enemy.push(part); part.parent = boss;
            boss.w = boss.w / 3;
            boss.h = boss.h / 3;
            for (var j = 0; j < Taps.length; j++) { Taps[j].x = Taps[j].y = 0; }
            tapLocationSet(Taps, 0, 0, 0);
            for (var i = 0; i < Taps.length; i++) { Taps[i].check = 0; }
        }
        function createTap(Taps, i, parentDirection, parentNum) {
            var tap;
            if (i == 0) {
                tap = { type: "Tap", TapType: "Start", Links: new Array(4), Enemy: new Array(), clear: 0, check: 0, x: 0, y: 0 };
                Taps.push(tap);
                tap.Links[0] = tap.Links[1] = tap.Links[2] = tap.Links[3] = -1;
                tap.Links[parentDirection] = parentNum;
                var randDir = Math.floor(Math.random() * 4);
                for (var j = 0; j < 4; j++) {
                    if (tap.Links[(randDir + j) % 4] == -1 && Taps.length < System.TapSize) {
                        var c = false;
                        var nx = tap.x;
                        var ny = tap.y;
                        switch ((randDir + j) % 4) {
                            case 0: ny++; break;
                            case 1: nx++; break;
                            case 2: ny--; break;
                            case 3: nx--; break;
                        }
                        for (var k = 0; k < Taps.length; k++) {
                            if (Taps[k].x == nx && Taps[k].y == ny) { c = true; }
                        }
                        if (c == true) { continue; }
                        tap.Links[(randDir + j) % 4] = Taps.length;
                        if (Taps.length + 1 >= System.TapSize) { System.TapSize = Taps.length + 2; }
                        createTap(Taps, Taps.length, ((randDir + j) % 4 + 2) % 4, i);
                    }
                }
                for (var i = 1; i < 2; i++) {
                    tap.Enemy.push(makeEne(i, 100 * i, 100));
                }
            }
            else {
                tap = { type: "Tap", TapType: "Normal", Links: new Array(4), Enemy: new Array(), clear: 0, check: 0, x: 0, y: 0 };
                Taps.push(tap);
                tap.Links[0] = tap.Links[1] = tap.Links[2] = tap.Links[3] = -1;
                tap.Links[parentDirection] = parentNum;
                tap.x = Taps[parentNum].x;
                tap.y = Taps[parentNum].y;
                switch (parentDirection) {
                    case 0: tap.y--; break;
                    case 1: tap.x--; break;
                    case 2: tap.y++; break;
                    case 3: tap.x++; break;
                }
                for (var j = 0; j < 4; j++) {
                    if (tap.Links[j] == -1 && Taps.length < System.TapSize) {
                        var c = false;
                        var nx = tap.x;
                        var ny = tap.y;
                        switch (j) {
                            case 0: ny++; break;
                            case 1: nx++; break;
                            case 2: ny--; break;
                            case 3: nx--; break;
                        }
                        for (var k = 0; k < Taps.length; k++) {
                            if (Taps[k].x == nx && Taps[k].y == ny) { c = true; }
                        }
                        if (c == true) { continue; }
                        if (Math.random() < (Taps.length) / (System.TapSize * parentNum)) {
                            tap.Links[j] = Taps.length;
                            createTap(Taps, Taps.length, (j + 2) % 4, i);
                        }
                    }
                }
            }
            return tap;
        }
        function tapLocationSet(Taps, tapIdx, dx, dy) {
            if (tapIdx > Taps.length || tapIdx < 0) { return; }
            var tap = Taps[tapIdx];
            if (tap.check == 1) { return; }
            tap.x = dx;
            tap.y = dy;
            tap.check = 1;

            tapLocationSet(Taps, tap.Links[0], tap.x, tap.y + 1);
            tapLocationSet(Taps, tap.Links[1], tap.x + 1, tap.y);
            tapLocationSet(Taps, tap.Links[2], tap.x, tap.y - 1);
            tapLocationSet(Taps, tap.Links[3], tap.x - 1, tap.y);
        }

        function makeEne(ty, x1, y1) {
            var mkene;
            var esize = 15;
            if (ty == 1)
                mkene = { type: "enemy", enemyType: "square1", x: x1, y: y1, mSpeed: 20, aSpeed: 5, bullet: 1, heart: 20, mhp: 20, w: esize, h: esize, size: esize, angle: 0 };
            else if (ty == 2)
                mkene = { type: "enemy", enemyType: "square2", x: x1, y: y1, mSpeed: 24, aSpeed: 5, bullet: 1, heart: 16, mhp: 16, w: esize, h: esize, size: esize, angle: 0 };
            else if (ty == 3)
                mkene = { type: "enemy", enemyType: "square3", x: x1, y: y1, mSpeed: 0, aSpeed: 10, bullet: 2, heart: 80, mhp: 80, w: esize * 12, h: esize * 12, size: esize * 12, angle: 0 };
            else if (ty == 4)
                mkene = { type: "enemy", enemyType: "square4", x: x1, y: y1, mSpeed: 0, aSpeed: 10, bullet: 1, heart: 40, mhp: 40, w: esize * 4, h: esize * 4, size: esize * 4, angle: 0 };
            else if (ty == 5)
                mkene = { type: "enemy", enemyType: "square5", x: x1, y: y1, mSpeed: 0, aSpeed: 10, bullet: 1, heart: 40, mhp: 40, w: esize * 4, h: esize * 4, size: esize * 4, ran: -1, angle: 0 };
            else if (ty == 6)
                mkene = { type: "enemy", enemyType: "squareBoss", x: x1, y: y1, mSpeed: 0, aSpeed: 10, bullet: 1, heart: 40, mhp: 40, w: esize * 9, h: esize * 9, size: esize * 9, ran: -1, angle: 0, parts: new Array(), leg: esize * 3 };
            else if (ty == 7)
                mkene = { type: "enemy", enemyType: "squarePart", x: x1, y: y1, mSpeed: 0, aSpeed: 10, bullet: 1, heart: 40, mhp: 40, w: esize * 3, h: esize * 3, size: esize * 3, ran: -1, angle: 0, parent: null };
            else if (ty == 8)
                mkene = { type: "enemy", enemyType: "squareBu", x: x1, y: y1, mSpeed: 0, aSpeed: 10, bullet: 1, heart: 40, mhp: 40, w: esize * 3, h: esize * 3, size: esize * 3, ran: -1, angle: 0 };

            return mkene;
        }
        function addBullet() {
            for (var i = 0; i < Taps[System.CurrentTap].Enemy.length; i++) {
                var enemy = Taps[System.CurrentTap].Enemy[i];
                if (enemy.enemyType == "square1") {
                    var ang = 45;
                    for (var n = 0; n < 4; n++) {
                        createBullet(enemy.x, enemy.y, "eBullet", "repl", 100, ang, 3, 1);
                        ang += 90;
                    }
                }
                if (enemy.enemyType == "square2") {
                    var ang = 0;
                    for (var n = 0; n < 4; n++) {
                        createBullet(enemy.x, enemy.y, "eBullet", "sin", 30, ang, 3, 2);
                        ang += 90;
                    }
                }
                if (enemy.enemyType == "square3") {
                    var random = Math.floor(Math.random() * 4) + 1;
                    for (var n = 0; n < 10; n++) {
                        ////console.log(enemy.x + enemy.w / 2+n*3);
                        //if (random == 1)
                        //    createBullet(enemy.x + n * 3 + enemy.w / 2, enemy.y + enemy.h / 2, "eBullet", "lazor", 3, random, 3, 2);
                        //else if (random == 2)
                        //    createBullet(enemy.x - n * 3 + enemy.w / 2, enemy.y + enemy.h / 2, "eBullet", "lazor", 3, random, 3, 2);
                        //else if (random == 3)
                        //    createBullet(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2 + n * 3, "eBullet", "lazor", 3, random, 3, 2);
                        //else if (random == 4)
                        //    createBullet(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2 - n * 3, "eBullet", "lazor", 3, random, 3, 2);
                    }
                }
            }
        }
        function emoving1(Enemy) {
            var x1 = Enemy.x - Player.x;
            var y1 = Enemy.y - Player.y;
            var i = Math.sqrt(x1 * x1 + y1 * y1);
            if (i > 100) {
                if (x1 <= 0 && y1 <= 0) {
                    Enemy.x += 0.1;
                    Enemy.y += 0.1;
                }
                else if (x1 <= 0 && y1 > 0) {
                    Enemy.x += 0.1;
                    Enemy.y -= 0.1;
                }
                else if (x1 > 0 && y1 <= 0) {
                    Enemy.x -= 0.1;
                    Enemy.y += 0.1;
                }
                else {
                    Enemy.x -= 0.1;
                    Enemy.y -= 0.1;
                }
            }

            if (Enemy.x <= 0)
                Enemy.x = 0;
            if (Enemy.x + Enemy.w >= Canvas.width)
                Enemy.x = Canvas.width - Enemy.w - 1;
            if (Enemy.y <= 0)
                Enemy.y = 0;
            if (Enemy.y + Enemy.h >= Canvas.height)
                Enemy.y = Canvas.height - Enemy.h - 1;
        }
        function emoving2(Enemy) {
            var x1 = Enemy.x - Player.x;
            var y1 = Enemy.y - Player.y;
            var i = Math.sqrt(x1 * x1 + y1 * y1);
            if (i > 100) {
                if (x1 <= 0 && y1 <= 0) {
                    Enemy.x -= 0.1;
                    Enemy.y -= 0.1;
                }
                else if (x1 <= 0 && y1 > 0) {
                    Enemy.x -= 0.1;
                    Enemy.y += 0.1;
                }
                else if (x1 > 0 && y1 <= 0) {
                    Enemy.x += 0.1;
                    Enemy.y -= 0.1;
                }
                else {
                    Enemy.x += 0.1;
                    Enemy.y += 0.1;
                }
            }
            else {

            }
            if (Enemy.x <= 0)
                Enemy.x = 0;
            if (Enemy.x + Enemy.w >= Canvas.width)
                Enemy.x = Canvas.width - Enemy.w - 1;
            if (Enemy.y <= 0)
                Enemy.y = 0;
            if (Enemy.y + Enemy.h >= Canvas.height)
                Enemy.y = Canvas.height - Enemy.h - 1;
        }
        function emoving3(Enemy) {
            var random = Math.floor(Math.random() * 2) + 1;
            if (Enemy.ran == -1) {
                if (random == 1) {
                    if (Player.x >= Enemy.x + Enemy.w / 2)
                        Enemy.ran = 1;
                    else
                        Enemy.ran = 2;
                }
                else {
                    if (Player.y >= Enemy.y + Enemy.h / 2)
                        Enemy.ran = 3;
                    else
                        Enemy.ran = 4;
                }
            }
            if (Enemy.ran == 1) {
                Enemy.x -= 0.1;
            }
            else if (Enemy.ran == 2) {
                Enemy.x += 0.1;
            }
            else if (Enemy.ran == 3) {
                Enemy.y -= 0.1;
            }
            else if (Enemy.ran == 4) {
                Enemy.y += 0.1;
            }
            if (Enemy.x - (Enemy.w / 8 * Math.sqrt(2)) <= 0) {
                Enemy.ran = -1;
                Enemy.x += 0.1;
            }
            if (Enemy.x + (Enemy.w / 8 * Math.sqrt(2)) + Enemy.w >= Canvas.width) {
                Enemy.ran = -1;
                Enemy.x -= 0.1;
            }
            if (Enemy.y - (Enemy.h / 8 * Math.sqrt(2)) <= 0) {
                Enemy.ran = -1;
                Enemy.y += 0.1;
            }
            if (Enemy.y + (Enemy.h / 8 * Math.sqrt(2)) + Enemy.h >= Canvas.height) {
                Enemy.ran = -1;
                Enemy.y -= 0.1;
            }
        }

        var attcking1, attcking2, slowMove;
        attcking1 = attcking2 = slowMove = 0;
        function onKeyDownFunc(e) {
            e.preventDefault();
            e.stopPropagation();
            if (e.keyCode == 87 && Player.dy > -1) {        //w
                Player.dy--;
                if (Player.dy == 0) setTimeout(onKeyDownFunc(e), 1);
            }
            else if (e.keyCode == 65 && Player.dx > -1) {    //a
                Player.dx--;
                if (Player.dx == 0) setTimeout(onKeyDownFunc(e), 1);
            }
            else if (e.keyCode == 83 && Player.dy < 1) {     //s
                Player.dy++;
                if (Player.dy == 0) setTimeout(onKeyDownFunc(e), 1);
            }
            else if (e.keyCode == 68 && Player.dx < 1) {     //d
                Player.dx++;
                if (Player.dx == 0) setTimeout(onKeyDownFunc(e), 1);
            }
            else if (e.keyCode == 32) {  //space
                attcking1 = 1;
            }
            else if (e.keyCode == 16) {  //shift
                slowMove = 1;
            }
        }
        function onKeyUpFunc(e) {
            e.preventDefault();
            e.stopPropagation();
            if (e.keyCode == 87 && Player.dy < 1) {         //w
                Player.dy = 0;
            }
            else if (e.keyCode == 65 && Player.dx < 1) {    //a
                Player.dx = 0;
            }
            else if (e.keyCode == 83 && Player.dy > -1) {   //s
                Player.dy = 0;
            }
            else if (e.keyCode == 68 && Player.dx > -1) {   //d
                Player.dx = 0;
            }
            else if (e.keyCode == 32) {  //space
                attcking1 = 0;
            }
            else if (e.keyCode == 16) {  //shift
                slowMove = 0;
            }
        }
        function onMouseMoveFunc(e) {
            e.preventDefault();
            e.stopPropagation();
            var rect = Canvas.getBoundingClientRect();
            Cursor.x = e.clientX - rect.left;
            Cursor.y = e.clientY - rect.top;
        }
        function onMouseDownFunc(e) {
            if (e.button == 0) { attcking2 = 1; }
        }
        function onMouseUpFunc(e) {
            if (e.button == 0) { attcking2 = 0; }
        }

        function drawCircle(x, y, r, sa, ea, f) {
            Context.beginPath();
            Context.arc(x, y, r, sa, ea, true);
            Context.closePath();
            if (f == true) { Context.fill(); }
            else { Context.stroke(); }
        }
        function drawRect(x, y, w, h, f) {
            Context.beginPath();
            Context.rect(x - w / 2, y - h / 2, w, h);
            Context.closePath();
            if (f == true) { Context.fill(); }
            else { Context.stroke(); }
        }
        function drawRhombus(x, y, w, h, f) {
            Context.setTransform(1, 0, 0, 1, 0, 0);
            Context.translate(x + (w / 2), y - (h / 5));
            Context.rotate(Math.PI / 4);
            Context.fillRect(0, 0, w, h);
            Context.setTransform(1, 0, 0, 1, 0, 0);
        }
        function drawTri(x, y, w, h, f) {
            var w1 = w / 4;
            var h1 = h / 4;
            var r2 = Math.sqrt(2);
            for (var i = 0; i < 4; i++) {
                Context.beginPath();
                Context.moveTo(x + w1 * i, y);
                Context.lineTo(x + w1 / 2 + w1 * i, y - h1 / 2 * r2);
                Context.lineTo(x + w1 + w1 * i, y);
                Context.closePath();
                Context.fill();
                Context.beginPath();
                Context.moveTo(x + w1 * i, y + h);
                Context.lineTo(x + w1 / 2 + w1 * i, y + h1 / 2 * r2 + h);
                Context.lineTo(x + w1 + w1 * i, y + h);
                Context.closePath();
                Context.fill();
                Context.beginPath();
                Context.moveTo(x, y + h1 * i);
                Context.lineTo(x - (w1 / 2 * r2), y + h1 / 2 + h1 * i);
                Context.lineTo(x, y + h1 * i + h1);
                Context.closePath();
                Context.fill();
                Context.beginPath();
                Context.moveTo(x + w, y + h1 * i);
                Context.lineTo(x + w + w1 / 2 * r2, y + h1 / 2 + h1 * i);
                Context.lineTo(x + w, y + h1 * i + h1);
                Context.closePath();
                Context.fill();
            }
        }
    }

    function gameOver(px, py, pscore) {
        var Canvas = document.getElementById('canvas');
        var Context = Canvas.getContext('2d');
        document.getElementById('container').style.left = window.innerWidth / 2 - 400 + 'px';
        Context.globalCompositeOperation = "source-over";
        Context.fillStyle = '#FFFFFF';
        Context.strokeStyle = '#000000';
        Context.font = "48px Product Sans";

        setTimeout(startGameOver, 1 / 60);
        var size = 0;
        function startGameOver() {
            Context.beginPath();
            Context.arc(px, py, size, 0, Math.PI * 2);
            Context.fill(); Context.closePath();
            size += 1.5;
            if (size > 1000) {
                size = 100;
                setTimeout(overDraw, 1 / 60);
            }
            else { setTimeout(startGameOver, 1 / 60); }
        }

        var theta = 0;
        var start = 0;
        var click = 0;
        function overDraw() {
            Canvas.style.backgroundColor = "white";
            Context.clearRect(0, 0, Canvas.width, Canvas.height);
            Context.strokeRect(3, 3, Canvas.width - 6, Canvas.height - 6);
            Context.fillStyle = '#000000';
            Context.font = "48px Product Sans";
            Context.globalCompositeOperation = "source-over";
            var s = size;
            var t = theta;
            var x = Canvas.width / 2;
            var y = Canvas.height / 3;
            Context.setTransform(1, 0, 0, 1, 0, 0);
            Context.translate(x + Math.cos(Math.PI / 180 * (135 - t)) * s * Math.sqrt(2) / 2, y + Math.sin(Math.PI / 180 * (135 - t)) * s * Math.sqrt(2) / 2);
            Context.rotate(-t * Math.PI / 180);
            Context.fillRect(0, 0, s, -s);
            Context.setTransform(1, 0, 0, 1, 0, 0);
            t = -t;
            Context.translate(x + Math.cos(Math.PI / 180 * (135 - t)) * s * Math.sqrt(2) / 2, y + Math.sin(Math.PI / 180 * (135 - t)) * s * Math.sqrt(2) / 2);
            Context.rotate(-t * Math.PI / 180);
            Context.fillRect(0, 0, s, -s);
            Context.setTransform(1, 0, 0, 1, 0, 0);
            for (var i = 0; i < 500000 + pscore; i++) {
                s += 8 + i;
                t *= -0.99;
                if (s < 0) continue;
                if (theta / 4 <= i) break;
                Context.translate(x + Math.cos(Math.PI / 180 * (135 - t)) * s * Math.sqrt(2) / 2, y + Math.sin(Math.PI / 180 * (135 - t)) * s * Math.sqrt(2) / 2);
                Context.rotate(-t * Math.PI / 180);
                Context.strokeRect(0, 0, s, -s);
                Context.setTransform(1, 0, 0, 1, 0, 0);
            }

            Context.globalCompositeOperation = "xor";
            Context.fillText("Game", 330, 180);
            Context.fillText("Over.", 330, 230);
            Context.font = "24px Product Sans";
            Context.fillText("Your_Score: [" + pscore + "]", 10, 540);
            Context.fillText("Press_F5_To_Restart_The_Game", 10, 580);
            Context.globalCompositeOperation = "source-over";
            if (s < 1000) { theta += 0.00025 * s; }
            else { theta += 0.00025 * 1000; }

            if (s > -256) { setTimeout(overDraw, 1 / 60); }
            else { size = 0; start = 1; }
        }
    }
    </script>
</head>
<body bgColor="black">
    <div id="container" style="position: absolute; top: 20px; left: 50px;">
        <canvas id="canvas" width="800" height="600">
            Your browser does not support the HTML 5 Canvas.
        </canvas>
    </div>
</body>
</html>